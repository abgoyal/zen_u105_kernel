#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <sys/time.h>
#include "dev_interf.h"

//#include <stdio.h>
#define TROUT_DBG_DEV_NAME "/dev/trout_dbg"
#define DMAC_DFT {0x08, 0x08, 0x08, 0x08, 0x08, 0x08}
#define PKT_DFT_LEN 2048
#define PKT_DFT_LOOP 100
#define TEST_END_MSG "test end!"
#define TEST_END_OFST 1024
#define TEST_END_MSG_PKT_LEN (TEST_END_OFST + strlen(TEST_END_MSG) + 1)
#define TEST_END_ACK "test ack:"
#define TEST_END_ACK_PKT_LEN (TEST_END_OFST + strlen(TEST_END_ACK) + 8 + 1)


int strmac2hex(unsigned char hexmac[], char *strmac)
{
    unsigned char i, temp8, *ptr8;
    
    ptr8 = (unsigned char *)strmac;
    for(i=0; i<6; i++)
    {
        temp8 = *ptr8++;
        if(temp8 >= '0' && temp8 <= '9')
        {
            hexmac[i] = (temp8 - '0') << 4;
        }
        else if((temp8 >= 'a' && temp8 <= 'f') || (temp8 >= 'A' && temp8 <= 'F'))
        {
            hexmac[i] = ((temp8 - 'a') + 10) << 4;
        }
        else
        {
            printf("bad dest mac!\n");
            return -1;
        }
    
        //low 4bits of char.
        temp8 = *ptr8++;
        if(temp8 >= '0' && temp8 <= '9')
        {
            hexmac[i] |= (temp8 - '0') ;
        }
        else if((temp8 >= 'a' && temp8 <= 'f') || (temp8 >= 'A' && temp8 <= 'F'))
        {
            hexmac[i] |= ((temp8 - 'a') + 10);
        }
        else
        {
            printf("bad dest mac!\n");
            return -1;
        }
    
        //skip separator.
        ptr8++;  
    }

    if(hexmac[0] & 1)
    {
        printf("bad dest mac: unsupported broadcast or multicast address!\n");
        return -1;
    }

    return 0;
}

void hex_dump(char *info, char *str, int len)
{
	int  i = 0;
    if(str == NULL || len == 0)
        return;
    
	printf("dump %s, len: %d; data:\n",info, len);
    
	for(i = 0; i<len; i++)
	{
		if(((char *)str+i)==NULL)
			break;
		printf("%02x ",*((char *)str+i));
		if((i+1)%16 == 0)
			printf("\n");
	}
    
	printf("\n");
}


static char pkt_sample[1552] = {
#if 0
    0x88, 0x01, 0x17, 0xce, 0xd8, 0x5d, 0x4c, 0x5c, 0xdf, 0x0c, 0x06, 0x06, 0x06, 0x06, 0x06, 0x08,
#else
    0x88, 0x02, 0x17, 0xce, 0xd8, 0x5d, 0x4c, 0x5c, 0xdf, 0x0c, 0x06, 0x06, 0x06, 0x06, 0x06, 0x08,
#endif

    0xd8, 0x5d, 0x4c, 0x5c, 0xdf, 0x0c, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xd8, 0x5d, 0x4c, 0x5c, 0xdf, 0x0c, 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00,
    0x45, 0x00, 0x05, 0xdc, 0x00, 0x00, 0x40, 0x00, 0x40, 0x01, 0xb1, 0x61, 0xc0, 0xa8, 0x01, 0x6e,
    0xc0, 0xa8, 0x01, 0x01, 0x08, 0x00, 0x08, 0x57, 0x6b, 0x0a, 0x00, 0x01, 0x16, 0x91, 0x20, 0x4d,
    0xd0, 0x6c, 0x04, 0x00, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,
    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,
    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,
    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,
    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,
    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,
    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,
    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,
    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,
    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,
    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,
    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,
    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,
    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,
    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,
    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,
    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,
    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,
    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,
    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,
    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,
    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,
    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,
    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,
    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,
    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,
    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,
    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0x00, 0x00, 0x00, 0x00
};

static int doTx(int dfd, unsigned char dmac[], int pkt_len, int loop_cnt)
{
    int i, rx_timeout;
    int ret = -1;
    char *pkt_ptr = pkt_sample;
    unsigned int fail_cnt = 0;
    struct timeval time_s, time_e;
    unsigned long long tlen = 0, rtlen = 0;
    unsigned int time_delta = 0;
    float rate = 0;
    unsigned int tx_countb[4] = {0}, tx_counta[4] = {0};

    //set dest mac address
    memcpy(pkt_ptr + 4, dmac, 6);
    gettimeofday(&time_s, NULL);
    printf("Tx begin at: %lu:%lu.\n", time_s.tv_sec, time_s.tv_usec);
    //tx data to peer.
    ioctl(dfd, TROUT_IOC_GTXRXCOUNT, &tx_countb[0]);
    
    for(i=0; ((loop_cnt < 0) ? 1 : (i<loop_cnt)); i++)
    {
        ret = write(dfd, pkt_ptr, pkt_len);
        if(ret < 0)
        {
            usleep(5000);
            fail_cnt++; 
        }
    }

    gettimeofday(&time_e, NULL);
    sleep(2);   //waif for H/W complete.
    
    ioctl(dfd, TROUT_IOC_GTXRXCOUNT, &tx_counta[0]);

    printf("Tx end at: %lu:%lu.\n", time_e.tv_sec, time_e.tv_usec);

    time_delta = ((time_e.tv_sec * 1000) + time_e.tv_usec / 1000 )
                 - ((time_s.tv_sec * 1000) + (time_s.tv_usec/ 1000));

    printf("Tx time(ms): %u.\n", time_delta);
    printf("Tx pkt number: %u.\n", loop_cnt);
    printf("  S/W success: %u, drop: %u.\n", (loop_cnt - fail_cnt), fail_cnt);
    printf("  H/W success: %u, fail: %u.\n", tx_counta[0]-tx_countb[0], tx_counta[1]-tx_countb[1]);

    tlen = (unsigned long long)(loop_cnt - fail_cnt) * pkt_len;
    rate = ((((float)tlen * 1000)/ time_delta) * 8) / (1024 * 1024);
    printf("Tx rate: %f Mbps.\n", rate);

    return 0;
}

static int doTx8Rx(int dfd, unsigned char dmac[], int pkt_len, int loop_cnt)
{
    int i, rx_timeout;
    int ret = -1;
    char *pkt_ptr = pkt_sample;
    unsigned int tx_fail_cnt = 0, rx_ok_cnt = 0;
    struct timeval time_s, time_e, time_m1, time_m2;
    unsigned long long tlen = 0, rtlen = 0;
    unsigned int time_delta = 0;
    float rate = 0;
    char *rx_buffer = NULL;
    unsigned int txrx_countb[4] = {0}, txrx_counta[4] = {0};
   
    rx_buffer = (char *)malloc(PKT_DFT_LEN);
    if(rx_buffer == NULL)
    {
        printf("malloc pkt mem failed.\n");
        return -1;
    }
    

    //set dest mac address
    memcpy(pkt_ptr + 4, dmac, 6);
    gettimeofday(&time_s, NULL);
    printf("doTx8Rx begin at: %lu:%lu.\n", time_s.tv_sec, time_s.tv_usec);

    //start tx/rx
    rx_timeout = 0;
    ioctl(dfd, TROUT_IOC_SRXTIMEOUT, &rx_timeout);
    ioctl(dfd, TROUT_IOC_GTXRXCOUNT, &txrx_countb[0]);
    for(i=0; ((loop_cnt < 0) ? 1 : (i<loop_cnt)); i++)
    {
        ret = write(dfd, pkt_ptr, pkt_len);
        if(ret < 0)
        {
            usleep(5000);
            tx_fail_cnt++; 
        }

        ret = read(dfd, rx_buffer, PKT_DFT_LEN);
        if(ret > 0)
        {
            rtlen += ret;
            rx_ok_cnt++;
        }
    }

    //receive left data from peer.
    gettimeofday(&time_e, NULL);
    time_m2 = time_e;
    rx_timeout = 3;
    ioctl(dfd, TROUT_IOC_SRXTIMEOUT, &rx_timeout);
    while(1)
    {
        ret = read(dfd, rx_buffer, PKT_DFT_LEN);
        if(ret > 0)
        {
            rtlen += ret;
            rx_ok_cnt++;
            gettimeofday(&time_m2, NULL);
        }
        else
        {
            //printf("%s: rx timout!\n", __FUNCTION__);
            break;
        }
    }

    ioctl(dfd, TROUT_IOC_GTXRXCOUNT, &txrx_counta[0]);

    printf("Tx end at: %lu:%lu.\n", time_e.tv_sec, time_e.tv_usec);
    printf("Rx end at: %lu:%lu.\n", time_m2.tv_sec, time_m2.tv_usec);

    time_delta = ((time_e.tv_sec * 1000) + time_e.tv_usec / 1000 )
                 - ((time_s.tv_sec * 1000) + (time_s.tv_usec/ 1000));

    printf("tx time(ms): %u.\n", time_delta);
    printf("Tx pkt number: %u.\n", loop_cnt);
    printf("  S/W success: %u, drop: %u.\n", (loop_cnt - tx_fail_cnt), tx_fail_cnt);
    printf("  H/W success: %u, fail: %u.\n\n", txrx_counta[0]-txrx_countb[0], txrx_counta[1]-txrx_countb[1]);

    printf("Rx S/W success: %u.\n", rx_ok_cnt);
    printf("Rx H/W success: %u, fail: %u.\n", txrx_counta[2]-txrx_countb[2], txrx_counta[3]-txrx_countb[3]);

    tlen = (unsigned long long)(loop_cnt - tx_fail_cnt) * pkt_len;
    rate = ((((float)tlen * 1000)/ time_delta) * 8) / (1024 * 1024);
    
    printf("Tx rate: %f Mbps.\n", rate);

    time_delta = ((time_m2.tv_sec * 1000) + time_m2.tv_usec / 1000 )
                 - ((time_s.tv_sec * 1000) + (time_s.tv_usec/ 1000));

    rate = ((((float)rtlen * 1000)/ time_delta) * 8) / (1024 * 1024);
    
    printf("Rx rate: %f Mbps.\n", rate);

    free(rx_buffer);
    
    return 0;
}

static int doRx(int dfd)
{
    int i, ret = -1, rx_timeout = 0;
    char *pkt_ptr = NULL;
    unsigned int fail_cnt = 0, pkt_cnt = 0, ack_len;
    struct timeval time_s, time_e;
    unsigned long long rtlen = 0;
    unsigned int time_delta = 0;
    float rate = 0;
    unsigned int rx_countb[4] = {0}, rx_counta[4] = {0};

    pkt_ptr = (char *)malloc(PKT_DFT_LEN);
    if(pkt_ptr == NULL)
    {
        printf("malloc pkt mem failed.\n");
        return -1;
    }

    //rx first data from peer.
    rx_timeout = -1;
    ioctl(dfd, TROUT_IOC_SRXTIMEOUT, &rx_timeout);
    ioctl(dfd, TROUT_IOC_GTXRXCOUNT, &rx_countb[0]);
    ret = read(dfd, pkt_ptr, PKT_DFT_LEN);
    if(ret < 0)
    {
        printf("Rx failed: %d.\n", ret);
        free(pkt_ptr);
        return -1;
    }
    
    gettimeofday(&time_s, NULL);
    time_e = time_s;
    rtlen += ret;
    pkt_cnt++;
    
    memcpy(pkt_ptr + 4, &pkt_ptr[10], 6);
    printf("doRx begin at%lu.%lu, from: %02x:%02x:%02x:%02x:%02x:%02x.\n",
            time_s.tv_sec, time_s.tv_usec, pkt_ptr[10], pkt_ptr[11], pkt_ptr[12],
            pkt_ptr[13], pkt_ptr[14], pkt_ptr[15]);
    
    //rx left data from peer.
    rx_timeout = 3;
    ioctl(dfd, TROUT_IOC_SRXTIMEOUT, &rx_timeout);
    while(1)
    {
        ret = read(dfd, pkt_ptr, PKT_DFT_LEN);
        if(ret < 0)
        {
            ioctl(dfd, TROUT_IOC_GTXRXCOUNT, &rx_counta[0]);
            printf("Rx end at: %lu:%lu.\n", time_e.tv_sec, time_e.tv_usec);
            
            time_delta = ((time_e.tv_sec * 1000) + time_e.tv_usec / 1000 )
                         - ((time_s.tv_sec * 1000) + (time_s.tv_usec/ 1000));

            if(time_delta <= 2)
            {
                printf("rx time(ms): too short!\n");
                rate = 0;
            }
            else
            {
                printf("Rx time(ms): %u.\n", time_delta);
                printf("S/W success: %u.\n", pkt_cnt);
                printf("H/W success: %u, fail: %u.\n", rx_counta[2]-rx_countb[2], rx_counta[3]-rx_countb[3]);
                rate = ((((float)rtlen * 1000)/ time_delta) * 8) / (1024 * 1024);
            }
            
            printf("Rx rate: %f Mbps.\n", rate);

            break;
        }
        
        gettimeofday(&time_e, NULL);

        rtlen += ret;
        pkt_cnt++;
    }

    free(pkt_ptr);
    
    return 0;
}

static int doRx8Tx(int dfd)
{
    int i, rx_timeout = 0;
    int ret = -1, rx_fail_flag = 0;
    char *pkt_ptr = pkt_sample;
    unsigned int tx_ok_cnt = 0, tx_fail_cnt = 0, rx_ok_cnt = 0;
    struct timeval time_s, time_e, time_m1, time_m2;
    unsigned long long tlen = 0, rtlen = 0;
    unsigned int time_delta = 0;
    float rate = 0;
    char *rx_buffer = NULL;
    unsigned int txrx_countb[4] = {0}, txrx_counta[4] = {0};
   
    rx_buffer = (char *)malloc(PKT_DFT_LEN);
    if(rx_buffer == NULL)
    {
        printf("malloc pkt mem failed.\n");
        return -1;
    }

    //rx first data from peer.
    rx_timeout = -1;
    ioctl(dfd, TROUT_IOC_SRXTIMEOUT, &rx_timeout);
    ioctl(dfd, TROUT_IOC_GTXRXCOUNT, &txrx_countb[0]);
    ret = read(dfd, rx_buffer, PKT_DFT_LEN);
    if(ret <= 0)
    {
        printf("Rx8Tx read0 fail.\n");
        free(rx_buffer);
        
        return -1;
    }
    
    gettimeofday(&time_s, NULL);
    
    rtlen += ret;
    rx_ok_cnt++;
    //set dest mac address
    memcpy(pkt_ptr + 4, &rx_buffer[10], 6);
    printf("doRx8Tx begin at%lu.%lu, from: %02x:%02x:%02x:%02x:%02x:%02x.\n",
            time_s.tv_sec, time_s.tv_usec, rx_buffer[10], rx_buffer[11], rx_buffer[12],
            rx_buffer[13], rx_buffer[14], rx_buffer[15]);
    
    rx_timeout = 3;    //rx timeout is 3second.
    ioctl(dfd, TROUT_IOC_SRXTIMEOUT, &rx_timeout);
    //tx/rx left data to/from peer.
    while(1)
    {
        ret = write(dfd, pkt_ptr, ret);
        if(ret <= 0)
        {
            tx_fail_cnt++;
        }

        tlen += ret;
        tx_ok_cnt++;
        ret = read(dfd, rx_buffer, PKT_DFT_LEN);
        if(ret <= 0)
        {
            //printf("%s: rx timout!\n", __FUNCTION__);
            break;
        }

        rx_fail_flag = 0;
        gettimeofday(&time_e, NULL);
        
        rtlen += ret;
        rx_ok_cnt++;
    }
    
    ioctl(dfd, TROUT_IOC_GTXRXCOUNT, &txrx_counta[0]);
    
    printf("Rx end at: %lu:%lu.\n", time_e.tv_sec, time_e.tv_usec);

    time_delta = ((time_e.tv_sec * 1000) + time_e.tv_usec / 1000 )
                 - ((time_s.tv_sec * 1000) + (time_s.tv_usec/ 1000));

    printf("Rx time(ms): %u.\n", time_delta);
    printf("Rx S/W success: %u.\n", rx_ok_cnt);
    printf("Rx H/W success: %u, fail: %u.\n\n", txrx_counta[2]-txrx_countb[2], txrx_counta[3]-txrx_countb[3]);
    printf("Tx S/W success: %u, drop: %u\n", tx_ok_cnt, tx_fail_cnt);
    printf("Tx H/W success: %u, fail: %u.\n", txrx_counta[0]-txrx_countb[0], txrx_counta[1]-txrx_countb[1]);

    rate = ((((float)tlen * 1000)/ time_delta) * 8) / (1024 * 1024);
    printf("Tx rate: %f Mbps.\n", rate);

    rate = ((((float)rtlen * 1000)/ time_delta) * 8) / (1024 * 1024);
    
    printf("Rx rate: %f Mbps.\n", rate);

    return 0;
}



void printUsaging(char *argv)
{
    printf("usaging: %s <mode> [dest mac] [loop] [pkt size]\n", argv);
    printf("    <mode>:  t: only TX; r: only RX; t8: TX and RX; r8: RX and TX.\n");
    printf("[dest mac]:  dest board mac address, format: xx:xx:xx:xx:xx:xx. only valid in Tx mode.\n");
    printf("    [loop]:  Tx packet count, only valid in t and t8 mode.\n");
    printf("[pkt size]:  Tx packet size(byte), only valid in t and t8 mode.\n");
}

int main(int args, char *argv[])
{
    int dfd = -1, i = 0, ret = -1, rlen = 0, wlen = 0;
    unsigned int pkt_len = sizeof(pkt_sample);
    unsigned long long tlen = 0;
    char role = 'T';
    char *ptr8 = NULL;
    unsigned char temp8, dmac[6] = DMAC_DFT;
    int loop_cnt = PKT_DFT_LOOP;
    
    printf("--------------- Trout board to board Tx/Rx test tool ---------------\n");
    printf("version: 1.00, created at %s.\n", __DATE__ ", " __TIME__);
    printf(" Author: Hugh\n\n");
    printf("--------------------------------------------------------------------\n");
    
    if(args < 2)
    {
        printf("too few argment!\n");
        printUsaging(argv[0]);
        return -1;
    }

    if(*argv[1] == 'T' || *argv[1] == 't') 
    {
        role = 'T';         //tx mode
    }
    else if(*argv[1] == 'R' || *argv[1] == 'r')
    {
        role = 'R';         //only rx mode
        if(*(argv[1] + 1) == '8')
            role = 'r';    //rx and tx mode.
    }
    else
    {
        printf("bad mode: %s\n", argv[1]);
        printUsaging(argv[0]);
        return -1;
    }
    
    if(role == 'T')
    {
        if(*(argv[1] + 1) =='8')
            role = 't';    //tx and rx mode.
        
        memcpy(dmac, &pkt_sample[16], 6);
        if(args >= 3)
        {
            //get dest mac address
            if(strlen(argv[2]) != (12+5))
            {
                printf("invalid dest mac length!\n");
                printUsaging(argv[0]);
                return -1;
            }
            
            if(strmac2hex(dmac, argv[2]) < 0)
            {
                printUsaging(argv[0]);
                return -1;
            }

            memcpy(&pkt_sample[4], dmac, 6);
        }

        //get tx loop count
        if(args >= 4)
        {
            loop_cnt = strtol(argv[3], NULL, 0);
            if(loop_cnt == 0)
            {
                printf("loop_cnt is 0! using default:%u.\n", PKT_DFT_LOOP);
                loop_cnt = PKT_DFT_LOOP;
            }
            else if(loop_cnt < 0)
            {
                loop_cnt = -1;
            }
        }
        
        //get packet length
        if(args >= 5)
        {
            pkt_len = strtoul(argv[4], NULL, 0);
            if(pkt_len < 84)
            {
                pkt_len = sizeof(pkt_sample);
                printf("pkt length is too short! using default:%u.\n", pkt_len);
            }
        }        
        
    }

    printf("device: %s\n", TROUT_DBG_DEV_NAME);
    if(role == 'T')
        printf("  mode: Tx only.\n");
    else if(role == 'R')
        printf("  mode: Rx only.\n");
    else if(role == 't')
        printf("  mode: Tx8Rx.\n");
    else if(role == 'r')
        printf("  mode: Rx8Tx.\n");
    else
    {
        printf("  mode: invalid mode!\n");
        return -1;
    }
    
    if(role == 'T' || role == 't')
    {
        printf("  dmac: %02x:%02x:%02x:%02x:%02x:%02x\n", dmac[0], dmac[1], dmac[2], dmac[3], dmac[4], dmac[5]);
//        printf("  smac: %02x:%02x:%02x:%02x:%02x:%02x\n", pkt_sample[10], pkt_sample[11], pkt_sample[12], pkt_sample[13], pkt_sample[14], pkt_sample[15]);
//        printf(" bssid: %02x:%02x:%02x:%02x:%02x:%02x\n", pkt_sample[4], pkt_sample[5], pkt_sample[6], pkt_sample[7], pkt_sample[8], pkt_sample[9]);
        printf("pktlen: %u\n", pkt_len);
        printf(" loops: %u\n", loop_cnt);
    }

    printf("open <%s> ... ", TROUT_DBG_DEV_NAME);
    
    dfd = open(TROUT_DBG_DEV_NAME, O_RDWR);
    if(dfd < 0)
    {
        printf("fail.\n");
        return -1;
    }
    
    printf("OK.\n");


    switch(role)
    {
        case 'T':
            ret = doTx(dfd, dmac, pkt_len, loop_cnt);
            if(ret < 0)
            {
                printf("Tx fail.\n");
            }
            else
            {
                printf("Tx ok.\n");
            }

            break;

        case 't':
            ret = doTx8Rx(dfd, dmac, pkt_len, loop_cnt);
            if(ret < 0)
            {
                printf("Tx8Rx fail.\n");
            }
            else
            {
                printf("Tx8Rx ok.\n");
            }
        
            break;
    
        case 'R':
            ret = doRx(dfd);
            if(ret < 0)
            {
                printf("Rx failed.\n");
            }
            else
            {
                printf("Rx ok.\n");
            }
        
            break;
        
        case 'r':
            ret = doRx8Tx(dfd);
            if(ret < 0)
            {
                printf("Rx8Tx fail.\n");
            }
            else
            {
                printf("Rx8Tx ok.\n");
            }
        
            break;
            
        default:
            printf("unknown role!\n");
            break;
    }

    close(dfd);
    
    printf("######### test end #########\n");

    return 0;
}


